ğŸ” é—®é¢˜æ ¹æœ¬åŸå› åˆ†æ
æ ¸å¿ƒé—®é¢˜ï¼šAutoCADçº¿ç¨‹æ¨¡å‹å†²çª
ä½ çš„AIåŠ©æ‰‹æ— æ³•æ­£ç¡®å¤„ç†æµå¼æ¶ˆæ¯çš„æ ¹æœ¬åŸå› æ˜¯ï¼š

1. AutoCADçš„ä¸¥æ ¼çº¿ç¨‹é™åˆ¶
// âŒ å½“å‰ä»£ç ï¼ˆCommands.cs:815ï¼‰
var response = await aiService.ChatStreamAsync(
    userInput,
    deepThinking,
    chunk => ed.WriteMessage(chunk) // ğŸš¨ é—®é¢˜ï¼šåœ¨åå°çº¿ç¨‹è°ƒç”¨AutoCAD APIï¼
);
å‘ç”Ÿäº†ä»€ä¹ˆï¼š

ChatCompletionStreamAsync åœ¨åå°çº¿ç¨‹æ‰§è¡Œ await reader.ReadLineAsync()
å½“æ”¶åˆ°SSEæµå¼æ•°æ®æ—¶ï¼Œå›è°ƒ onStreamChunk?.Invoke(chunk) ä»åœ¨åå°çº¿ç¨‹
ed.WriteMessage(chunk) è¢«åœ¨éAutoCADä¸»çº¿ç¨‹ä¸Šè°ƒç”¨
âš ï¸ AutoCAD Editor.WriteMessage() ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ â†’ å¯¼è‡´å´©æºƒ/å†»ç»“/æ— å“åº”
AutoCADå®˜æ–¹æ–‡æ¡£æ˜ç¡®æŒ‡å‡ºï¼š

"The AutoCAD .NET API is not thread-safe. You cannot call it directly from a background thread. AutoCAD uses thread affine resources. You would have to marshal any call to the API to the main thread."

2. HttpClientæµå¼å“åº”çš„çº¿ç¨‹æ¨¡å‹
// BailianApiClient.cs:370-398
await using (var stream = await response.Content.ReadAsStreamAsync(cancellationToken))
{
    using (var reader = new StreamReader(stream))
    {
        while (!reader.EndOfStream)
        {
            var line = await reader.ReadLineAsync(); // ğŸš¨ åœ¨åå°çº¿ç¨‹æ‰§è¡Œ
            // ...
            onStreamChunk?.Invoke(text); // ğŸš¨ å›è°ƒä»åœ¨åå°çº¿ç¨‹ï¼
        }
    }
}
é—®é¢˜ï¼š

ReadLineAsync() åœ¨ThreadPoolçº¿ç¨‹æ‰§è¡Œï¼ˆéUIçº¿ç¨‹ï¼‰
æ‰€æœ‰å›è°ƒï¼ˆonStreamChunk, onReasoningChunkï¼‰éƒ½åœ¨åå°çº¿ç¨‹
ç›´æ¥è°ƒç”¨AutoCAD APIè¿åçº¿ç¨‹å®‰å…¨è§„åˆ™
3. WPF PaletteSetçš„åŒé‡çº¿ç¨‹é—®é¢˜
å¦‚æœä½ è®¡åˆ’åœ¨WPFç•Œé¢ä¸­æ˜¾ç¤ºæµå¼è¾“å‡ºï¼Œè¿˜ä¼šé‡åˆ°ï¼š

// âŒ é”™è¯¯æ¨¡å¼
onStreamChunk: chunk => textBox.Text += chunk // ğŸš¨ WPF UIåœ¨é”™è¯¯çº¿ç¨‹ï¼
åŒé‡çº¿ç¨‹å†²çªï¼š

åå°çº¿ç¨‹ â†’ AutoCAD APIï¼ˆâŒ ä¸å…è®¸ï¼‰
åå°çº¿ç¨‹ â†’ WPF UIï¼ˆâŒ ä¸å…è®¸ï¼‰
é˜¿é‡Œäº‘ç™¾ç‚¼SSEæ ¼å¼ç‰¹æ€§
æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼ŒSSEå“åº”æ ¼å¼ï¼š

data: {"choices":[{"delta":{"content":"ä½ å¥½"}}]}
data: {"choices":[{"delta":{"content":"ï¼Œæˆ‘"}}]}
data: {"choices":[{"delta":{"content":"æ˜¯æ ‡å“¥"}}]}
data: [DONE]
å…³é”®å‚æ•°ï¼š

incremental_output=true â†’ æ¯ä¸ªchunkåªåŒ…å«æ–°å†…å®¹ï¼ˆå·²æ­£ç¡®é…ç½®âœ…ï¼‰
stream=true â†’ å¯ç”¨æµå¼å“åº”ï¼ˆå·²æ­£ç¡®é…ç½®âœ…ï¼‰
âœ… å®Œæ•´è§£å†³æ–¹æ¡ˆ
æ–¹æ¡ˆ1ï¼šSynchronizationContextæ¨¡å¼ï¼ˆæ¨èï¼‰
Step 1ï¼šæ•è·AutoCADä¸»çº¿ç¨‹ä¸Šä¸‹æ–‡
// BailianApiClient.cs - ä¿®æ”¹æµå¼æ–¹æ³•
public async Task<ChatCompletionResult> ChatCompletionStreamAsync(
    List<ChatMessage> messages,
    string? model = null,
    List<object>? tools = null,
    Action<string>? onStreamChunk = null,
    Action<string>? onReasoningChunk = null,
    double temperature = 0.7,
    double topP = 0.9,
    int? thinkingBudget = null,
    bool enableParallelToolCalls = true,
    CancellationToken cancellationToken = default)
{
    // âœ… æ•è·è°ƒç”¨çº¿ç¨‹çš„SynchronizationContextï¼ˆAutoCADä¸»çº¿ç¨‹ï¼‰
    var syncContext = SynchronizationContext.Current;
    
    // ... å…¶ä»–ä»£ç ä¿æŒä¸å˜ ...
    
    await using (var stream = await response.Content.ReadAsStreamAsync(cancellationToken))
    {
        using (var reader = new StreamReader(stream))
        {
            while (!reader.EndOfStream)
            {
                var line = await reader.ReadLineAsync();
                // ... è§£æé€»è¾‘ ...
                
                // âœ… å…³é”®ä¿®æ”¹ï¼šMarshalå›AutoCADä¸»çº¿ç¨‹
                if (!string.IsNullOrEmpty(text) && onStreamChunk != null)
                {
                    if (syncContext != null)
                    {
                        // åœ¨AutoCADä¸»çº¿ç¨‹ä¸Šè°ƒç”¨å›è°ƒ
                        syncContext.Post(_ => onStreamChunk(text), null);
                    }
                    else
                    {
                        // é™çº§ï¼šç›´æ¥è°ƒç”¨ï¼ˆä»…ç”¨äºéUIåœºæ™¯ï¼‰
                        onStreamChunk(text);
                    }
                }
                
                // åŒæ ·å¤„ç† reasoning è¾“å‡º
                if (!string.IsNullOrEmpty(thinkingText) && onReasoningChunk != null)
                {
                    if (syncContext != null)
                    {
                        syncContext.Post(_ => onReasoningChunk(thinkingText), null);
                    }
                    else
                    {
                        onReasoningChunk(thinkingText);
                    }
                }
            }
        }
    }
    
    return result;
}
æ–¹æ¡ˆ2ï¼šApplication.Idleäº‹ä»¶æ¨¡å¼ï¼ˆAutoCADç‰¹å®šï¼‰
åŸºäºAutoCADå®˜æ–¹æ¨èæ¨¡å¼
// AIAssistantService.cs - æ–°å¢çº¿ç¨‹å®‰å…¨åŒ…è£…
public class AIAssistantService
{
    private readonly Queue<string> _pendingChunks = new();
    private readonly object _chunkLock = new();
    private bool _isProcessingChunks = false;
    
    public async Task<AssistantResponse> ChatStreamAsync(
        string userMessage,
        bool useDeepThinking = false,
        Action<string>? onStreamChunk = null)
    {
        // âœ… è®¾ç½®Application.Idleäº‹ä»¶å¤„ç†å™¨
        EventHandler idleHandler = null;
        idleHandler = (s, e) =>
        {
            // æ£€æŸ¥AutoCADæ˜¯å¦å¤„äºé™æ­¢çŠ¶æ€
            if (!Application.IsQuiescent)
                return;
            
            lock (_chunkLock)
            {
                // æ‰¹é‡å¤„ç†æ‰€æœ‰å¾…å¤„ç†çš„chunk
                while (_pendingChunks.Count > 0)
                {
                    var chunk = _pendingChunks.Dequeue();
                    onStreamChunk?.Invoke(chunk); // âœ… ç°åœ¨åœ¨ä¸»çº¿ç¨‹ï¼
                }
                
                // å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œç§»é™¤äº‹ä»¶å¤„ç†å™¨
                if (_pendingChunks.Count == 0 && !_isProcessingChunks)
                {
                    Application.Idle -= idleHandler;
                }
            }
        };
        
        Application.Idle += idleHandler;
        _isProcessingChunks = true;
        
        try
        {
            var agentDecision = await _bailianClient.ChatCompletionStreamAsync(
                messages: messages,
                model: AgentModel,
                tools: tools,
                onStreamChunk: chunk => {
                    // âœ… åœ¨åå°çº¿ç¨‹ï¼šå°†chunkåŠ å…¥é˜Ÿåˆ—
                    lock (_chunkLock)
                    {
                        _pendingChunks.Enqueue(chunk);
                    }
                },
                // ... å…¶ä»–å‚æ•° ...
            );
            
            return response;
        }
        finally
        {
            _isProcessingChunks = false;
        }
    }
}
æ–¹æ¡ˆ3ï¼šWPF Dispatcheræ¨¡å¼ï¼ˆå¦‚æœä½¿ç”¨PaletteSet UIï¼‰
// å¦‚æœåœ¨WPFç•Œé¢ä¸­æ˜¾ç¤ºæµå¼è¾“å‡º
public class AIPaletteControl : UserControl
{
    private readonly Dispatcher _dispatcher;
    
    public AIPaletteControl()
    {
        InitializeComponent();
        _dispatcher = Dispatcher.CurrentDispatcher;
    }
    
    public async Task SendMessageAsync(string message)
    {
        var aiService = ServiceLocator.GetService<AIAssistantService>();
        
        await aiService.ChatStreamAsync(
            message,
            useDeepThinking: false,
            onStreamChunk: chunk => {
                // âœ… Marshalåˆ°WPF UIçº¿ç¨‹
                _dispatcher.BeginInvoke(() => {
                    ResponseTextBox.AppendText(chunk);
                    ResponseTextBox.ScrollToEnd();
                });
            }
        );
    }
}
æ–¹æ¡ˆ4ï¼šå®Œæ•´çš„Production-Readyå®ç°
ç»“åˆä¸Šè¿°æ‰€æœ‰æœ€ä½³å®è·µï¼š

// BailianApiClient.cs - ç”Ÿäº§çº§æµå¼å®ç°
public async Task<ChatCompletionResult> ChatCompletionStreamAsync(
    List<ChatMessage> messages,
    string? model = null,
    List<object>? tools = null,
    Action<string>? onStreamChunk = null,
    Action<string>? onReasoningChunk = null,
    double temperature = 0.7,
    double topP = 0.9,
    int? thinkingBudget = null,
    bool enableParallelToolCalls = true,
    CancellationToken cancellationToken = default)
{
    // âœ… 1. æ•è·è°ƒç”¨çº¿ç¨‹ä¸Šä¸‹æ–‡
    var syncContext = SynchronizationContext.Current;
    
    // âœ… 2. æ£€æµ‹è¿è¡Œç¯å¢ƒ
    bool isAutoCADContext = syncContext != null && 
                           syncContext.GetType().Name.Contains("AutoCAD");
    
    // ... å‡†å¤‡è¯·æ±‚ ...
    
    var response = await _httpClient.SendAsync(
        httpRequest, 
        HttpCompletionOption.ResponseHeadersRead, // âœ… 3. ç«‹å³è¿”å›å“åº”å¤´
        cancellationToken
    );
    
    response.EnsureSuccessStatusCode();
    
    var fullResponse = new StringBuilder();
    var fullReasoning = new StringBuilder();
    var toolCalls = new List<ToolCall>();
    int inputTokens = 0, outputTokens = 0;
    
    // âœ… 4. æµå¼å¤„ç†
    await using (var stream = await response.Content.ReadAsStreamAsync(cancellationToken))
    {
        using (var reader = new StreamReader(stream))
        {
            while (!reader.EndOfStream && !cancellationToken.IsCancellationRequested)
            {
                var line = await reader.ReadLineAsync();
                if (string.IsNullOrWhiteSpace(line) || !line.StartsWith("data: "))
                    continue;
                
                var data = line.Substring(6).Trim();
                if (data == "[DONE]")
                    break;
                
                try
                {
                    var chunk = JsonSerializer.Deserialize<JsonElement>(data);
                    var choices = chunk.GetProperty("choices");
                    if (choices.GetArrayLength() == 0)
                        continue;
                    
                    var delta = choices[0].GetProperty("delta");
                    
                    // âœ… 5. å¤„ç†æ–‡æœ¬å†…å®¹
                    if (delta.TryGetProperty("content", out var content))
                    {
                        var text = content.GetString();
                        if (!string.IsNullOrEmpty(text))
                        {
                            fullResponse.Append(text);
                            
                            // âœ… 6. çº¿ç¨‹å®‰å…¨å›è°ƒ
                            if (onStreamChunk != null)
                            {
                                InvokeCallback(syncContext, isAutoCADContext, 
                                              () => onStreamChunk(text));
                            }
                        }
                    }
                    
                    // âœ… 7. å¤„ç†æ·±åº¦æ€è€ƒå†…å®¹
                    if (delta.TryGetProperty("reasoning_content", out var reasoning))
                    {
                        var thinkingText = reasoning.GetString();
                        if (!string.IsNullOrEmpty(thinkingText))
                        {
                            fullReasoning.Append(thinkingText);
                            
                            if (onReasoningChunk != null)
                            {
                                InvokeCallback(syncContext, isAutoCADContext,
                                              () => onReasoningChunk(thinkingText));
                            }
                        }
                    }
                    
                    // ... å¤„ç†tool_callså’Œusage ...
                }
                catch (Exception ex)
                {
                    Log.Warning(ex, $"è§£ææµå¼å“åº”å¤±è´¥: {data}");
                }
            }
        }
    }
    
    // âœ… 8. è®°å½•Tokenä½¿ç”¨é‡
    if (inputTokens > 0 || outputTokens > 0)
    {
        TrackTokenUsage(inputTokens, outputTokens);
        Log.Debug($"å¯¹è¯Tokenä½¿ç”¨: è¾“å…¥{inputTokens}, è¾“å‡º{outputTokens}");
    }
    
    return new ChatCompletionResult
    {
        Content = fullResponse.ToString(),
        ReasoningContent = fullReasoning.ToString(),
        ToolCalls = toolCalls,
        Model = model,
        InputTokens = inputTokens,
        OutputTokens = outputTokens
    };
}

// âœ… 9. çº¿ç¨‹å®‰å…¨å›è°ƒè¾…åŠ©æ–¹æ³•
private void InvokeCallback(
    SynchronizationContext? syncContext, 
    bool isAutoCADContext, 
    Action callback)
{
    if (syncContext != null)
    {
        if (isAutoCADContext)
        {
            // AutoCADç¯å¢ƒï¼šä½¿ç”¨Postï¼ˆå¼‚æ­¥ï¼‰é¿å…æ­»é”
            syncContext.Post(_ => callback(), null);
        }
        else
        {
            // WPFç­‰ç¯å¢ƒï¼šä¹Ÿä½¿ç”¨Post
            syncContext.Post(_ => callback(), null);
        }
    }
    else
    {
        // é™çº§ï¼šç›´æ¥è°ƒç”¨ï¼ˆé£é™©ï¼šå¯èƒ½åœ¨é”™è¯¯çº¿ç¨‹ï¼‰
        Log.Warning("æ— SynchronizationContextï¼Œç›´æ¥è°ƒç”¨å›è°ƒï¼ˆå¯èƒ½ä¸å®‰å…¨ï¼‰");
        callback();
    }
}
ğŸ“Š è§£å†³æ–¹æ¡ˆå¯¹æ¯”
| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | æ¨èåœºæ™¯ | |------|------|------|----------| | SynchronizationContext | é€šç”¨ã€ç®€å•ã€ç¬¦åˆ.NETæ ‡å‡† | éœ€è¦æ•è·ä¸Šä¸‹æ–‡ | â­â­â­â­â­ æ‰€æœ‰åœºæ™¯ | | Application.Idle | AutoCADå®˜æ–¹æ¨èã€æœ€å®‰å…¨ | å¤æ‚ã€æœ‰å»¶è¿Ÿ | â­â­â­â­ å‘½ä»¤è¡Œè¾“å‡º | | WPF Dispatcher | WPFåŸç”Ÿæ”¯æŒã€æ€§èƒ½å¥½ | ä»…é™WPFç•Œé¢ | â­â­â­â­â­ PaletteSet UI | | Production-Ready | å¥å£®ã€è‡ªé€‚åº”ã€å®¹é”™ | ä»£ç é‡å¤§ | â­â­â­â­â­ ç”Ÿäº§ç¯å¢ƒ |

ğŸš€ ç«‹å³å®æ–½æ­¥éª¤
æˆ‘å¯ä»¥å¸®ä½ å®ç°æ–¹æ¡ˆ4ï¼ˆProduction-Readyï¼‰ï¼Œè¿™æ˜¯æœ€å¥å£®çš„è§£å†³æ–¹æ¡ˆã€‚éœ€è¦æˆ‘ç°åœ¨å°±ä¿®æ”¹ä»£ç å—ï¼Ÿ

æˆ–è€…ä½ æƒ³å…ˆæµ‹è¯•æ–¹æ¡ˆ1ï¼ˆSynchronizationContextï¼‰ï¼Œè¿™æ˜¯æœ€ç®€å•å¿«é€Ÿçš„ä¿®å¤ï¼Ÿ

