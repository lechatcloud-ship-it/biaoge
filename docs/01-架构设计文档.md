# DWG图纸翻译及算量桌面应用 - 架构设计文档

## 文档信息
- **项目名称**: DWG智能翻译算量系统
- **版本**: v1.0
- **创建日期**: 2025-11-07
- **最后更新**: 2025-11-07

---

## 1. 项目概述

### 1.1 项目背景
随着建筑工程行业国际化发展，对CAD图纸的跨语言翻译和自动化算量需求日益增长。本项目旨在开发一款桌面端应用，利用阿里云百炼大模型能力，实现DWG图纸的智能翻译和精准算量。

### 1.2 核心功能
- DWG/DXF图纸文件的解析与渲染
- 基于阿里云百炼大模型的智能翻译（支持中英文及多语言）
- 自动化工程量计算与统计
- 翻译后图纸的重新生成与导出
- 算量结果HTML报表导出

### 1.3 技术目标
- **性能**: 10MB以内图纸加载时间 < 3秒
- **准确性**: 翻译准确率 > 95%，算量误差率 < 2%
- **可用性**: 支持Windows/macOS/Linux三大平台
- **可扩展性**: 模块化设计，便于功能迭代

---

## 2. 技术架构

### 2.1 总体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        表示层 (Presentation)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  图纸查看器  │  │  翻译管理界面│  │  算量报表界面│     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    业务逻辑层 (Business Logic)               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ 图纸解析模块 │  │  翻译引擎模块│  │  算量计算模块│     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ 导出生成模块 │  │ 状态管理模块 │  │  缓存管理模块│     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                     数据访问层 (Data Access)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ DWG解析引擎  │  │百炼API客户端 │  │  本地数据库  │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                    基础设施层 (Infrastructure)               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │  文件系统    │  │   网络层     │  │   日志系统   │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 技术栈选型

#### 2.2.1 桌面应用框架
**选择: Tauri 2.0**

理由：
- ✅ 轻量级：应用体积小（< 5MB），内存占用低（比Electron节省50%+）
- ✅ 安全性高：使用系统原生WebView，避免打包Chromium
- ✅ 跨平台：一套代码支持Windows/macOS/Linux
- ✅ 性能优秀：Rust后端，原生性能
- ✅ 现代化：2025年主流趋势，生态快速发展

架构：
```
Frontend (Web)          Backend (Rust)
┌──────────────┐       ┌──────────────┐
│   React 18   │◄─────►│  Tauri Core  │
│  TypeScript  │  IPC  │     Rust     │
│   Vite 5.x   │       │              │
└──────────────┘       └──────────────┘
```

#### 2.2.2 前端技术栈
- **UI框架**: React 18 + TypeScript 5.x
- **状态管理**: Zustand（轻量级）
- **UI组件库**: Ant Design 5.x（企业级UI）
- **图纸渲染**:
  - Three.js（3D渲染引擎）
  - Konva.js（2D Canvas渲染）
- **构建工具**: Vite 5.x
- **样式**: TailwindCSS + CSS Modules

#### 2.2.3 后端技术栈（Rust）
- **核心框架**: Tauri 2.0
- **DWG解析**:
  - libredwg（通过FFI调用）
  - 自研解析层（处理特殊格式）
- **HTTP客户端**: reqwest（调用阿里云API）
- **数据库**: SQLite（本地数据存储）
- **序列化**: serde + serde_json

#### 2.2.4 第三方服务
- **大模型服务**: 阿里云百炼平台
  - 模型选择: Qwen-Plus（平衡性能与成本）
  - 备选: Qwen-Max（高精度场景）
- **OCR服务**: 阿里云OCR（图纸文字识别）

---

## 3. 核心模块设计

### 3.1 图纸解析模块 (DWG Parser Module)

#### 3.1.1 模块职责
- 解析DWG/DXF文件格式
- 提取图层、实体、文本、标注等元素
- 构建图纸对象模型（DOM）
- 处理不同版本的DWG格式（R13-R2024）

#### 3.1.2 技术方案

**方案A: 纯JavaScript方案**
```typescript
// 使用 libredwg-web（WebAssembly）
import { DwgParser } from 'libredwg-web';

interface DwgEntity {
  type: 'LINE' | 'CIRCLE' | 'TEXT' | 'MTEXT' | 'DIMENSION' | ...;
  layer: string;
  color: string;
  properties: Record<string, any>;
}

class DwgParserService {
  async parseDwg(file: File): Promise<DwgDocument> {
    const buffer = await file.arrayBuffer();
    const parser = new DwgParser();
    return parser.parse(buffer);
  }
}
```

**方案B: Rust FFI方案**（推荐）
```rust
// src-tauri/src/dwg_parser.rs
use libredwg_sys::{dwg_read_file, dwg_free};

#[tauri::command]
pub async fn parse_dwg_file(path: String) -> Result<DwgDocument, String> {
    // 使用libredwg C库解析
    let dwg = unsafe { dwg_read_file(&path) }?;

    // 提取实体
    let entities = extract_entities(&dwg);

    // 释放内存
    unsafe { dwg_free(&dwg) };

    Ok(DwgDocument { entities })
}
```

#### 3.1.3 数据模型
```typescript
interface DwgDocument {
  version: string;           // DWG版本
  layers: Layer[];           // 图层列表
  entities: Entity[];        // 实体列表
  blocks: Block[];           // 图块列表
  textStyles: TextStyle[];   // 文本样式
  dimStyles: DimStyle[];     // 标注样式
  metadata: Metadata;        // 元数据
}

interface Entity {
  id: string;
  type: EntityType;
  layer: string;
  geometry: Geometry;
  properties: EntityProperties;
  text?: TextContent;        // 文本内容（如果有）
}

interface TextContent {
  original: string;          // 原始文本
  translated?: string;       // 翻译后文本
  position: Point3D;
  rotation: number;
  height: number;
  style: string;
}
```

### 3.2 翻译引擎模块 (Translation Engine)

#### 3.2.1 翻译流程
```
┌─────────────┐
│ 提取文本    │
│ (Extract)   │
└──────┬──────┘
       ↓
┌─────────────┐
│ 文本预处理  │  ← 过滤非文本、标准化格式
│ (Preprocess)│
└──────┬──────┘
       ↓
┌─────────────┐
│ 批量翻译    │  ← 调用阿里云百炼API
│ (Translate) │
└──────┬──────┘
       ↓
┌─────────────┐
│ 结果映射    │  ← 将翻译结果映射回实体
│ (Mapping)   │
└──────┬──────┘
       ↓
┌─────────────┐
│ 质量检查    │  ← 验证翻译完整性
│ (QA)        │
└─────────────┘
```

#### 3.2.2 实现方案
```typescript
// src/services/translation/TranslationEngine.ts
import { BailianClient } from '@/services/bailian';

interface TranslationConfig {
  sourceLanguage: string;
  targetLanguage: string;
  model: 'qwen-plus' | 'qwen-max';
  batchSize: number;         // 批量翻译大小
  preserveFormatting: boolean; // 保留格式
}

class TranslationEngine {
  private bailianClient: BailianClient;
  private cache: Map<string, string>;

  async translateDrawing(
    document: DwgDocument,
    config: TranslationConfig
  ): Promise<TranslationResult> {
    // 1. 提取所有文本实体
    const textEntities = this.extractTextEntities(document);

    // 2. 去重并缓存查询
    const uniqueTexts = this.deduplicateTexts(textEntities);

    // 3. 批量翻译
    const translations = await this.batchTranslate(
      uniqueTexts,
      config
    );

    // 4. 映射回原文档
    return this.mapTranslations(document, translations);
  }

  private async batchTranslate(
    texts: string[],
    config: TranslationConfig
  ): Promise<Map<string, string>> {
    const results = new Map<string, string>();

    // 分批处理（避免单次请求过大）
    const batches = this.chunkArray(texts, config.batchSize);

    for (const batch of batches) {
      const prompt = this.buildTranslationPrompt(batch, config);

      const response = await this.bailianClient.complete({
        model: config.model,
        messages: [
          {
            role: 'system',
            content: '你是一个专业的建筑工程图纸翻译专家...'
          },
          {
            role: 'user',
            content: prompt
          }
        ],
        temperature: 0.3  // 低温度保证翻译稳定性
      });

      // 解析批量翻译结果
      const batchResults = this.parseTranslationResponse(response);
      batchResults.forEach((value, key) => results.set(key, value));
    }

    return results;
  }

  private buildTranslationPrompt(
    texts: string[],
    config: TranslationConfig
  ): string {
    return `
请将以下建筑工程图纸中的文本从${config.sourceLanguage}翻译成${config.targetLanguage}。

要求：
1. 保持专业术语的准确性
2. 保留原有格式（如数字、单位、符号）
3. 输出JSON格式：{"原文1": "译文1", "原文2": "译文2"}

待翻译文本：
${JSON.stringify(texts, null, 2)}
    `.trim();
  }
}
```

#### 3.2.3 阿里云百炼集成
```typescript
// src/services/bailian/BailianClient.ts
import axios, { AxiosInstance } from 'axios';

interface BailianConfig {
  apiKey: string;
  endpoint?: string;
  model?: string;
}

interface CompletionRequest {
  model: string;
  messages: Message[];
  temperature?: number;
  max_tokens?: number;
  stream?: boolean;
}

class BailianClient {
  private client: AxiosInstance;
  private config: BailianConfig;

  constructor(config: BailianConfig) {
    this.config = config;
    this.client = axios.create({
      baseURL: config.endpoint || 'https://dashscope.aliyuncs.com/api/v1',
      headers: {
        'Authorization': `Bearer ${config.apiKey}`,
        'Content-Type': 'application/json',
      },
      timeout: 60000,
    });
  }

  async complete(request: CompletionRequest): Promise<CompletionResponse> {
    const response = await this.client.post('/services/aigc/text-generation/generation', {
      model: request.model,
      input: {
        messages: request.messages,
      },
      parameters: {
        temperature: request.temperature ?? 0.7,
        max_tokens: request.max_tokens ?? 2000,
      },
    });

    if (response.data.output?.code !== 'Success') {
      throw new Error(`API Error: ${response.data.output?.message}`);
    }

    return response.data;
  }

  async *streamComplete(
    request: CompletionRequest
  ): AsyncGenerator<StreamChunk> {
    // 流式响应实现
    // ...
  }
}
```

### 3.3 算量计算模块 (Quantity Calculation)

#### 3.3.1 算量策略
```typescript
interface QuantityRule {
  entityType: EntityType;
  calculationType: 'LENGTH' | 'AREA' | 'VOLUME' | 'COUNT';
  formula: string;
  unit: string;
}

interface QuantityResult {
  category: string;           // 类别（墙体、门窗、钢筋等）
  items: QuantityItem[];
  summary: QuantitySummary;
}

interface QuantityItem {
  name: string;               // 项目名称
  specification: string;      // 规格型号
  quantity: number;           // 数量
  unit: string;               // 单位
  layer: string;              // 所属图层
  entities: string[];         // 关联实体ID
}

class QuantityCalculator {
  private rules: Map<string, QuantityRule>;

  async calculate(document: DwgDocument): Promise<QuantityResult> {
    const results: QuantityItem[] = [];

    // 1. 按图层分类实体
    const layerGroups = this.groupByLayer(document.entities);

    // 2. 识别构件类型（使用AI辅助识别）
    const components = await this.identifyComponents(layerGroups);

    // 3. 应用算量规则
    for (const component of components) {
      const rule = this.rules.get(component.type);
      if (rule) {
        const quantity = this.applyRule(component, rule);
        results.push(quantity);
      }
    }

    // 4. 汇总统计
    const summary = this.summarize(results);

    return { category: 'default', items: results, summary };
  }

  private async identifyComponents(
    layerGroups: Map<string, Entity[]>
  ): Promise<Component[]> {
    // 使用大模型识别构件类型
    const components: Component[] = [];

    for (const [layer, entities] of layerGroups) {
      const description = this.describeEntities(entities);

      const prompt = `
分析以下CAD图层中的实体，识别建筑构件类型：
图层名称：${layer}
实体描述：${description}

请返回JSON格式：
{
  "type": "墙体|柱|梁|板|门|窗|...",
  "properties": { "材质": "...", "规格": "..." }
}
      `;

      const response = await this.bailianClient.complete({
        model: 'qwen-plus',
        messages: [{ role: 'user', content: prompt }],
      });

      const componentInfo = JSON.parse(response.output.text);
      components.push({
        layer,
        entities,
        ...componentInfo,
      });
    }

    return components;
  }

  private applyRule(
    component: Component,
    rule: QuantityRule
  ): QuantityItem {
    let quantity = 0;

    switch (rule.calculationType) {
      case 'LENGTH':
        quantity = this.calculateTotalLength(component.entities);
        break;
      case 'AREA':
        quantity = this.calculateTotalArea(component.entities);
        break;
      case 'VOLUME':
        quantity = this.calculateTotalVolume(component.entities);
        break;
      case 'COUNT':
        quantity = component.entities.length;
        break;
    }

    return {
      name: component.type,
      specification: component.properties.规格 || 'N/A',
      quantity,
      unit: rule.unit,
      layer: component.layer,
      entities: component.entities.map(e => e.id),
    };
  }
}
```

#### 3.3.2 算量规则库
```typescript
// 预定义算量规则
const defaultRules: QuantityRule[] = [
  {
    entityType: 'LINE',
    calculationType: 'LENGTH',
    formula: 'SUM(length)',
    unit: 'm',
  },
  {
    entityType: 'POLYLINE',
    calculationType: 'LENGTH',
    formula: 'SUM(length)',
    unit: 'm',
  },
  {
    entityType: 'CIRCLE',
    calculationType: 'AREA',
    formula: 'PI * radius^2',
    unit: 'm²',
  },
  // 墙体算量
  {
    entityType: 'WALL',
    calculationType: 'AREA',
    formula: 'length * height',
    unit: 'm²',
  },
  // 自定义规则...
];
```

### 3.4 导出生成模块 (Export Generator)

#### 3.4.1 图纸导出
```typescript
interface ExportOptions {
  format: 'DWG' | 'DXF' | 'PDF' | 'SVG';
  version?: string;           // DWG版本（R2018, R2021等）
  preserveLayers: boolean;
  embedFonts: boolean;
}

class DrawingExporter {
  async export(
    document: DwgDocument,
    options: ExportOptions
  ): Promise<Blob> {
    switch (options.format) {
      case 'DWG':
        return this.exportToDwg(document, options);
      case 'DXF':
        return this.exportToDxf(document, options);
      case 'PDF':
        return this.exportToPdf(document, options);
      case 'SVG':
        return this.exportToSvg(document, options);
    }
  }

  private async exportToDwg(
    document: DwgDocument,
    options: ExportOptions
  ): Promise<Blob> {
    // 调用Rust后端进行DWG生成
    const result = await invoke<Uint8Array>('generate_dwg', {
      document,
      version: options.version || 'R2018',
    });

    return new Blob([result], { type: 'application/acad' });
  }

  private async exportToDxf(
    document: DwgDocument,
    options: ExportOptions
  ): Promise<Blob> {
    // DXF是文本格式，可以直接在前端生成
    const dxfContent = this.generateDxfContent(document);
    return new Blob([dxfContent], { type: 'application/dxf' });
  }

  private generateDxfContent(document: DwgDocument): string {
    let dxf = '0\nSECTION\n2\nHEADER\n';

    // 添加头部信息
    dxf += `9\n$ACADVER\n1\nAC1021\n`;  // AutoCAD 2007

    // 添加实体
    dxf += '0\nSECTION\n2\nENTITIES\n';
    for (const entity of document.entities) {
      dxf += this.entityToDxf(entity);
    }
    dxf += '0\nENDSEC\n';

    dxf += '0\nEOF\n';
    return dxf;
  }
}
```

#### 3.4.2 HTML报表导出
```typescript
interface ReportOptions {
  template: 'standard' | 'detailed' | 'summary';
  includeCharts: boolean;
  includeImages: boolean;
  theme: 'light' | 'dark';
}

class ReportGenerator {
  async generateHtmlReport(
    quantityResult: QuantityResult,
    options: ReportOptions
  ): Promise<string> {
    const template = this.loadTemplate(options.template);

    const data = {
      summary: quantityResult.summary,
      items: quantityResult.items,
      charts: options.includeCharts ? this.generateCharts(quantityResult) : null,
      metadata: {
        generatedAt: new Date().toISOString(),
        version: '1.0.0',
      },
    };

    // 使用模板引擎渲染
    return this.renderTemplate(template, data, options);
  }

  private renderTemplate(
    template: string,
    data: any,
    options: ReportOptions
  ): string {
    return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>工程量清单报表</title>
  <style>
    ${this.getStyles(options.theme)}
  </style>
</head>
<body class="${options.theme}">
  <div class="container">
    <header>
      <h1>工程量清单报表</h1>
      <p class="meta">生成时间：${new Date(data.metadata.generatedAt).toLocaleString('zh-CN')}</p>
    </header>

    <section class="summary">
      <h2>工程量汇总</h2>
      <table>
        <thead>
          <tr>
            <th>类别</th>
            <th>数量</th>
            <th>单位</th>
          </tr>
        </thead>
        <tbody>
          ${this.renderSummaryRows(data.summary)}
        </tbody>
      </table>
    </section>

    <section class="details">
      <h2>明细清单</h2>
      <table>
        <thead>
          <tr>
            <th>序号</th>
            <th>项目名称</th>
            <th>规格型号</th>
            <th>数量</th>
            <th>单位</th>
            <th>所属图层</th>
          </tr>
        </thead>
        <tbody>
          ${this.renderDetailRows(data.items)}
        </tbody>
      </table>
    </section>

    ${options.includeCharts ? this.renderCharts(data.charts) : ''}

    <footer>
      <p>DWG智能翻译算量系统 v${data.metadata.version}</p>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
  <script>
    ${this.getChartScripts(data.charts)}
  </script>
</body>
</html>
    `.trim();
  }

  private getStyles(theme: 'light' | 'dark'): string {
    const colors = theme === 'light'
      ? { bg: '#ffffff', text: '#333333', border: '#dddddd' }
      : { bg: '#1a1a1a', text: '#eeeeee', border: '#444444' };

    return `
      * { margin: 0; padding: 0; box-sizing: border-box; }
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
        background: ${colors.bg};
        color: ${colors.text};
        padding: 20px;
      }
      .container { max-width: 1200px; margin: 0 auto; }
      header { text-align: center; margin-bottom: 40px; }
      h1 { font-size: 32px; margin-bottom: 10px; }
      h2 { font-size: 24px; margin: 30px 0 15px; }
      .meta { color: #999; font-size: 14px; }
      table {
        width: 100%;
        border-collapse: collapse;
        margin: 20px 0;
        box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      }
      th, td {
        padding: 12px;
        text-align: left;
        border: 1px solid ${colors.border};
      }
      th {
        background: ${theme === 'light' ? '#f5f5f5' : '#2a2a2a'};
        font-weight: 600;
      }
      tbody tr:hover {
        background: ${theme === 'light' ? '#fafafa' : '#252525'};
      }
      .chart-container {
        margin: 30px 0;
        padding: 20px;
        background: ${theme === 'light' ? '#f9f9f9' : '#222222'};
        border-radius: 8px;
      }
      footer {
        text-align: center;
        margin-top: 60px;
        padding-top: 20px;
        border-top: 1px solid ${colors.border};
        color: #999;
      }
      @media print {
        body { padding: 0; }
        .no-print { display: none; }
      }
    `;
  }
}
```

---

## 4. 数据流设计

### 4.1 图纸翻译流程

```
用户操作              前端React              Tauri Backend           阿里云百炼
   │                    │                        │                       │
   ├─ 选择DWG文件 ────►│                        │                       │
   │                    ├─ 调用打开文件对话框 ──►│                       │
   │                    │◄─ 返回文件路径 ───────┤                       │
   │                    ├─ parse_dwg_file() ────►│                       │
   │                    │                        ├─ 解析DWG结构          │
   │                    │                        ├─ 提取实体信息          │
   │                    │◄─ 返回Document对象 ────┤                       │
   │                    ├─ 渲染图纸预览          │                       │
   │◄─ 显示预览 ────────┤                        │                       │
   │                    │                        │                       │
   ├─ 点击翻译按钮 ────►│                        │                       │
   │                    ├─ 提取文本实体          │                       │
   │                    ├─ translate_batch() ────►│                       │
   │                    │                        ├─ 调用百炼API ─────────►│
   │                    │                        │                       ├─ 翻译处理
   │                    │                        │◄─ 返回翻译结果 ────────┤
   │                    │◄─ 返回翻译Map ─────────┤                       │
   │                    ├─ 更新Document对象       │                       │
   │                    ├─ 重新渲染              │                       │
   │◄─ 显示翻译结果 ────┤                        │                       │
   │                    │                        │                       │
   ├─ 导出图纸 ────────►│                        │                       │
   │                    ├─ export_dwg() ─────────►│                       │
   │                    │                        ├─ 生成DWG文件          │
   │                    │◄─ 返回文件路径 ────────┤                       │
   │◄─ 保存成功提示 ────┤                        │                       │
```

### 4.2 算量计算流程

```
用户操作              前端React              Tauri Backend           算量引擎
   │                    │                        │                       │
   ├─ 点击算量按钮 ────►│                        │                       │
   │                    ├─ calculate_quantity()──►│                       │
   │                    │                        ├─ 按图层分组 ──────────►│
   │                    │                        │                       ├─ 识别构件类型
   │                    │                        │                       ├─ 应用算量规则
   │                    │                        │                       ├─ 几何计算
   │                    │                        │◄─ 返回算量结果 ────────┤
   │                    │◄─ QuantityResult ──────┤                       │
   │                    ├─ 渲染结果表格          │                       │
   │◄─ 显示算量清单 ────┤                        │                       │
   │                    │                        │                       │
   ├─ 导出HTML报表 ────►│                        │                       │
   │                    ├─ 生成HTML内容          │                       │
   │                    ├─ save_report() ────────►│                       │
   │                    │                        ├─ 保存文件              │
   │                    │◄─ 返回文件路径 ────────┤                       │
   │◄─ 导出成功 ────────┤                        │                       │
```

---

## 5. 性能优化策略

### 5.1 DWG解析优化
- **流式解析**: 大文件采用流式解析，避免一次性加载全部内容
- **多线程处理**: 使用Rust的异步特性并行处理多个图层
- **索引构建**: 为实体建立空间索引（R-tree），加速查询
- **懒加载**: 初次只加载必要信息，详细数据按需加载

### 5.2 渲染优化
- **LOD技术**: 根据缩放级别使用不同细节的模型
- **视锥剔除**: 只渲染可见区域的实体
- **Canvas分层**: 将静态图层和动态图层分离渲染
- **Web Worker**: 将复杂计算移至Worker线程

### 5.3 翻译优化
- **缓存机制**:
  - 内存缓存（LRU，最大10MB）
  - 本地数据库缓存（SQLite）
  - 相同文本自动使用缓存
- **批量处理**:
  - 单次最多处理100条文本
  - 并发请求数限制为3
- **去重优化**:
  - 提取前进行文本去重
  - 减少API调用次数

### 5.4 内存优化
- **对象池**: 重用频繁创建的对象
- **及时释放**: 及时释放不再使用的大对象（如原始DWG数据）
- **虚拟列表**: 算量结果使用虚拟滚动

---

## 6. 安全性设计

### 6.1 API密钥管理
```typescript
// 使用操作系统的密钥存储
import { invoke } from '@tauri-apps/api/tauri';

class SecureStorage {
  async setApiKey(key: string): Promise<void> {
    // 存储到系统密钥链（macOS Keychain / Windows Credential Manager / Linux Secret Service）
    await invoke('store_credential', {
      service: 'dwg-translator',
      account: 'bailian-api',
      password: key,
    });
  }

  async getApiKey(): Promise<string> {
    return await invoke('retrieve_credential', {
      service: 'dwg-translator',
      account: 'bailian-api',
    });
  }
}
```

### 6.2 数据传输安全
- 所有API调用使用HTTPS
- 文件传输使用加密通道
- 敏感数据不写入日志

### 6.3 本地数据保护
- SQLite数据库加密（使用SQLCipher）
- 临时文件使用后立即删除
- 缓存数据定期清理

---

## 7. 错误处理与日志

### 7.1 错误分类
```typescript
enum ErrorCode {
  // 文件相关
  FILE_NOT_FOUND = 'E1001',
  FILE_FORMAT_INVALID = 'E1002',
  FILE_CORRUPTED = 'E1003',

  // 解析相关
  PARSE_FAILED = 'E2001',
  UNSUPPORTED_VERSION = 'E2002',

  // 翻译相关
  TRANSLATION_API_ERROR = 'E3001',
  TRANSLATION_TIMEOUT = 'E3002',
  QUOTA_EXCEEDED = 'E3003',

  // 算量相关
  CALCULATION_ERROR = 'E4001',
  INVALID_RULE = 'E4002',

  // 导出相关
  EXPORT_FAILED = 'E5001',
  INSUFFICIENT_DISK_SPACE = 'E5002',
}

class AppError extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public details?: any
  ) {
    super(message);
  }
}
```

### 7.2 日志系统
```rust
// src-tauri/src/logger.rs
use log::{info, warn, error};

pub fn init_logger() {
    env_logger::Builder::new()
        .filter_level(log::LevelFilter::Info)
        .format_timestamp_secs()
        .init();
}

// 使用示例
info!("DWG file parsed successfully: {}", file_path);
warn!("Translation quota nearly exhausted: {}%", usage_percent);
error!("Failed to export DWG: {:?}", err);
```

---

## 8. 扩展性设计

### 8.1 插件系统（未来规划）
```typescript
interface Plugin {
  name: string;
  version: string;
  hooks: {
    onDocumentLoaded?: (doc: DwgDocument) => void;
    onTranslationComplete?: (result: TranslationResult) => void;
    onQuantityCalculated?: (result: QuantityResult) => void;
  };
}

class PluginManager {
  private plugins: Map<string, Plugin> = new Map();

  register(plugin: Plugin): void {
    this.plugins.set(plugin.name, plugin);
  }

  trigger(hookName: string, ...args: any[]): void {
    for (const plugin of this.plugins.values()) {
      const hook = plugin.hooks[hookName];
      if (hook) {
        hook(...args);
      }
    }
  }
}
```

### 8.2 自定义算量规则
- 支持用户自定义算量规则（JSON/YAML配置）
- 提供规则编辑器UI
- 规则导入导出功能

### 8.3 多语言支持
- i18n国际化框架
- 支持中文、英文、日文、韩文等
- 界面语言可切换

---

## 9. 部署架构

### 9.1 应用打包
```bash
# 构建命令
npm run tauri build

# 输出产物
- Windows: .msi / .exe
- macOS: .dmg / .app
- Linux: .AppImage / .deb / .rpm
```

### 9.2 自动更新
```typescript
import { checkUpdate, installUpdate } from '@tauri-apps/api/updater';

async function checkForUpdates() {
  const { shouldUpdate, manifest } = await checkUpdate();

  if (shouldUpdate) {
    const userConfirmed = await confirm(
      `发现新版本 ${manifest.version}，是否更新？`
    );

    if (userConfirmed) {
      await installUpdate();
      // 应用将自动重启
    }
  }
}
```

### 9.3 系统要求
- **操作系统**:
  - Windows 10/11 (64位)
  - macOS 11.0+
  - Linux (主流发行版，Kernel 3.10+)
- **内存**: 最低4GB，推荐8GB
- **磁盘**: 至少500MB可用空间
- **网络**: 需要互联网连接（调用API）

---

## 10. 监控与维护

### 10.1 性能监控
```typescript
class PerformanceMonitor {
  private metrics: Map<string, number[]> = new Map();

  measure(name: string, fn: () => Promise<any>): Promise<any> {
    const start = performance.now();
    const result = await fn();
    const duration = performance.now() - start;

    this.record(name, duration);

    if (duration > 1000) {
      console.warn(`Slow operation: ${name} took ${duration}ms`);
    }

    return result;
  }

  private record(name: string, duration: number): void {
    if (!this.metrics.has(name)) {
      this.metrics.set(name, []);
    }
    this.metrics.get(name)!.push(duration);
  }

  getStats(name: string): { avg: number; max: number; min: number } {
    const values = this.metrics.get(name) || [];
    return {
      avg: values.reduce((a, b) => a + b, 0) / values.length,
      max: Math.max(...values),
      min: Math.min(...values),
    };
  }
}
```

### 10.2 崩溃报告
- 集成Sentry或类似服务
- 自动收集崩溃堆栈
- 用户反馈通道

---

## 11. 附录

### 11.1 技术调研参考
- libredwg官方文档: https://www.gnu.org/software/libredwg/
- Tauri官方文档: https://tauri.app/
- 阿里云百炼文档: https://help.aliyun.com/zh/model-studio/
- Three.js文档: https://threejs.org/docs/

### 11.2 版本历史
| 版本 | 日期 | 说明 |
|-----|------|------|
| v1.0 | 2025-11-07 | 初始版本 |

### 11.3 团队协作
- **架构师**: 负责整体架构设计
- **前端开发**: React UI实现
- **后端开发**: Rust核心功能
- **测试工程师**: 功能测试、性能测试
- **产品经理**: 需求管理、迭代规划

---

**文档结束**
